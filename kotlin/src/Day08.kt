fun main() {

    fun List<String>.findAntennaGroups(): Map<Char, List<Pair<Int, Int>>> =
        // find all antennas on the map and group them by their name
        flatMapIndexed { row, s ->
            s.mapIndexed { col, c ->
                c to (row to col)
            }
        }.groupBy ({ it.first }, { it.second })
            .filter { it.key != '.' && it.value.size > 1 }

    fun List<String>.part1(): Int =
        findAntennaGroups()
            .values
            .flatMap { antennas ->
                // go over all antenna groups
                antennas.flatMapIndexed { idx, (antennaX, antennaY) ->
                    // for each antenna check against all other antennas in the group
                    // ignore duplicate combinations by checking the index
                    antennas.drop(idx + 1)
                        // calculate the antinodes created two antennas with the same frequency
                        .flatMap { (x, y) ->
                            listOf(
                                2 * antennaX - x to 2 * antennaY - y,
                                2 * x - antennaX to 2 * y - antennaY
                            )
                        }
                }
            }
            // we don't care how many antinodes overlap
            .toSet()
            // only count antinodes on the map
            .filter { it.first in indices && it.second in this[0].indices }
            .size


    fun List<String>.part2(): Any =
        findAntennaGroups()
            .values
            .flatMap { antennas ->
                // iterate over all antennas as before, ignore duplicate combinations by checking the index
                antennas.flatMapIndexed { idx, (antennaX, antennaY) ->
                    antennas.drop(idx + 1)
                        // this time we collect all antiondes that are generated up to the edges of the map
                        // always start at the antennas x and y to avoid going over the edge -> so no cleanup is needed later
                        .map { (x, y) -> x - antennaX to y - antennaY }
                        .flatMap { (dx, dy) ->
                            // antinodes generated by subtracting the difference
                            generateSequence(antennaX to antennaY) { (antinodeX, antinodeY) ->
                                if (antinodeX - dx in indices && antinodeY - dy in this[0].indices) {
                                    antinodeX - dx to antinodeY - dy
                                } else {
                                    null
                                }
                            }.toList().plus(
                                // antinodes generated by adding the difference, this will create an antinode on the other antenna
                                generateSequence(antennaX to antennaY) { (antinodeX, antinodeY) ->
                                    if (antinodeX + dx in indices && antinodeY + dy in this[0].indices) {
                                        antinodeX + dx to antinodeY + dy
                                    } else {
                                        null
                                    }
                                }.toList()
                            )
                        }
                }
            }
            .toSet()
            .size

    // Process input string
    val input = readInput("Day08")
        .filter { it.isNotEmpty() }

    // run task implementations
    println(input.part1())
    println(input.part2())
}
